package riemann_test

import (
	"math"
	"reflect"

	"github.com/alexsanjoseph/riemann-divisor-sum-go/riemann"
	"github.com/leanovate/gopter"
	"github.com/leanovate/gopter/gen"
	"github.com/leanovate/gopter/prop"
	. "github.com/onsi/ginkgo/v2"
	. "github.com/onsi/gomega"
)

var _ = Describe("Divisor Calculation", func() {

	Describe("Naive Divisor sum", func() {
		Context("should work on good cases", func() {
			It("Should give correct result", func() {
				output, err := riemann.DivisorSum(72)
				Expect(err).ShouldNot(HaveOccurred())
				Expect(output).To(Equal(int64(195)))
			})

			It("Should give correct result", func() {
				output, err := riemann.DivisorSum(1)
				Expect(err).ShouldNot(HaveOccurred())
				Expect(output).To(Equal(int64(1)))
			})
		})

		Context("should error out on bad cases", func() {
			It("zero value", func() {
				output, err := riemann.DivisorSum(0)
				Expect(output).To(BeZero())
				Expect(err).To(HaveOccurred())
			})

			It("negative value", func() {
				output, err := riemann.DivisorSum(-5)
				Expect(output).To(BeZero())
				Expect(err).To(HaveOccurred())
			})
		})

		It("should work on parametrized cases", func() {
			divisorSums := []int64{
				1, 3, 4, 7, 6, 12, 8, 15, 13, 18, 12, 28, 14, 24, 24, 31, 18, 39, 20, 42, 32,
				36, 24, 60, 31, 42, 40, 56, 30, 72, 32, 63, 48, 54, 48, 91, 38, 60, 56, 90, 42,
				96, 44, 84, 78, 72, 48, 124, 57, 93, 72,
			}

			for i, sum := range divisorSums {
				By("Passing each cases", func() {
					output, err := riemann.DivisorSum(int64(i) + 1)
					if err != nil {
						Fail("error should be nil")
					}
					Expect(output).To(Equal(sum))
				})
			}
		})
	})

	Describe("Prime factor divisor sum", func() {
		Context("should work on good cases", func() {
			It("For empty set", func() {
				inputArray := [][]int{}
				output, err := riemann.PrimeFactorDivisorSum(inputArray)
				if err != nil {
					Fail("error should be nil")
				}
				Expect(output).To(Equal(int64(1)))
			})

			It("For prime number", func() {
				inputArray := [][]int{{7, 1}}
				output, err := riemann.PrimeFactorDivisorSum(inputArray)
				if err != nil {
					Fail("error should be nil")
				}
				Expect(output).To(Equal(int64(8)))
			})

			It("For composite number", func() {
				inputArray := [][]int{{2, 3}, {3, 2}}
				output, err := riemann.PrimeFactorDivisorSum(inputArray)
				if err != nil {
					Fail("error should be nil")
				}
				Expect(output).To(Equal(int64(195)))
			})

			It("It gives error for non prime base", func() {
				inputArray := [][]int{{2, 3}, {4, 2}}
				_, err := riemann.PrimeFactorDivisorSum(inputArray)
				Expect(err).To(HaveOccurred())
			})

			It("It gives error for non unique base", func() {
				inputArray := [][]int{{2, 3}, {2, 2}}
				_, err := riemann.PrimeFactorDivisorSum(inputArray)
				Expect(err).To(HaveOccurred())
			})

			It("For large number, it errors", func() {
				inputArray := [][]int{{7, 10}, {29, 10}, {3, 14}}

				n := int64(1)
				for _, x := range inputArray {
					n *= int64(math.Pow(float64(x[0]), float64(x[1])))
				}

				_, err := riemann.PrimeFactorDivisorSum(inputArray)
				Expect(err).To(HaveOccurred())
			})

			It("For large number, it errors", func() {
				inputArray := [][]int{{17, 5}, {11, 5}, {13, 5}, {5, 15}}

				n := int64(1)
				for _, x := range inputArray {
					n *= int64(math.Pow(float64(x[0]), float64(x[1])))
				}

				_, err := riemann.PrimeFactorDivisorSum(inputArray)

				Expect(err).To(HaveOccurred())

			})
		})

		It("should work on autogenerated tests", func() {

			parameters := gopter.DefaultTestParameters()
			parameters.MinSuccessfulTests = 100
			parameters.MaxSize = 10
			properties := gopter.NewProperties(parameters)

			properties.Property("Check Prime Factor Divisor Sum", prop.ForAll(
				func(a, b []int) bool {

					smallerSliceLength := len(b)
					if len(a) <= len(b) {
						smallerSliceLength = len(a)
					}
					input := [][]int{}
					n := int64(1)

					for i := 0; i < smallerSliceLength; i++ {
						input = append(input, []int{a[i], b[i]})
						n *= int64(math.Pow(float64(a[i]), float64(b[i])))
					}

					resultA, err := riemann.PrimeFactorDivisorSum(input)
					if err != nil {
						return false
					}

					resultB, err := riemann.DivisorSum(n)

					if err != nil {
						return false
					}

					return resultA == resultB

				},
				gen.SliceOf(gen.IntRange(2, 20).SuchThat(func(v interface{}) bool { // Have to constrain because it doesn't work for large numbers yet
					return riemann.CheckIfPrime(v.(int))
				}),
					reflect.TypeOf(int(0))).SuchThat(func(v interface{}) bool {
					return riemann.CheckUniqueness(v.([]int))
				}).WithLabel("a"),
				gen.SliceOf(gen.IntRange(2, 5),
					reflect.TypeOf(int(0))).WithLabel("b"),
			))
			Expect(properties.Run(gopter.ConsoleReporter(true))).To(BeTrue())

		})
	})
})
